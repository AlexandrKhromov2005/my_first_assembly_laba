# Лабораторная работа №3: Утилита GNU Make

## Описание проекта

Этот проект демонстрирует продвинутое использование утилиты GNU Make для автоматизации сборки проекта, содержащего код на C и ассемблере (Intel и AT&T синтаксис).

Программа выполняет поворот квадратной матрицы на 90° по часовой стрелке с использованием ассемблерной функции для ускорения операций.

## Структура проекта

```
lab_1/
├── Makefile              # Главный продвинутый Makefile
├── src/                  # Исходные файлы
│   ├── main.c           # Главный C файл
│   ├── rotate.asm       # Ассемблерная функция (Intel синтаксис)
│   └── rotate_att.s     # Ассемблерная функция (AT&T синтаксис)
├── bin/                  # Скомпилированные файлы (создается автоматически)
│   ├── matrix_rotate    # Исполняемый файл
│   └── obj/             # Объектные файлы и зависимости
│       ├── *.o          # Объектные файлы
│       └── *.d          # Файлы зависимостей
├── task1/                # Предыдущая лаб. работа (задание 1)
└── task2/                # Предыдущая лаб. работа (задание 2)
```

## Особенности Makefile

### 1. Автоматизация
- **Автоматическое определение исходных файлов**: используется `wildcard` для поиска всех `.c` файлов
- **Автоматическая генерация зависимостей**: флаг `-MD` компилятора создает файлы `.d`
- **Включение зависимостей**: директива `-include $(wildcard *.d)` подключает файлы зависимостей

### 2. Структурирование
- Разделение на директории `src/` и `bin/`
- Использование переменных для всех важных параметров
- Поддержка переменной `VPATH` для поиска исходников

### 3. Динамическая компиляция
- **Выбор синтаксиса ассемблера**: `SYNTAX=intel` или `SYNTAX=att`
- **Метод ввода данных**: `INPUT_METHOD=console|file|random`
- **Режим отладки**: `DEBUG=yes|no`
- **Пользовательские флаги**: `COMPILE_FLAGS="-O2 -pipe"`

### 4. Шаблонные правила
```makefile
# Правило для компиляции C файлов
$(OBJ_DIR)/%.o: %.c | $(OBJ_DIR)
    $(CC) $(CFLAGS) -MD -c $< -o $@

# Правило для Intel ассемблера
$(OBJ_DIR)/%.o: %.asm | $(OBJ_DIR)
    $(ASM) $(ASMFLAGS) $< -o $@
```

### 5. Автоматические переменные
- `$@` - имя цели
- `$<` - первая зависимость
- `$^` - все зависимости

### 6. Фиктивные цели (PHONY)
Объявлены все служебные цели для предотвращения конфликтов с файлами:
```makefile
.PHONY: all run test clean distclean rebuild info help
```

## Использование

### Базовые команды

```bash
# Просмотр справки
make help

# Просмотр конфигурации
make info

# Сборка проекта (по умолчанию)
make
# или
make all

# Запуск программы
make run

# Запуск тестов
make test

# Очистка объектных файлов
make clean

# Полная очистка (включая исполняемый файл)
make distclean

# Пересборка
make rebuild
```

### Динамическая компиляция

#### 1. Выбор синтаксиса ассемблера

```bash
# Intel синтаксис (по умолчанию)
make

# AT&T синтаксис
make SYNTAX=att

# Сравнение обоих
make clean && make SYNTAX=intel && ./bin/matrix_rotate 3 0 10
make clean && make SYNTAX=att && ./bin/matrix_rotate 3 0 10
```

#### 2. Режим отладки

```bash
# Обычная сборка
make

# С отладочными символами
make DEBUG=yes

# Проверка наличия отладочной информации
make DEBUG=yes
file bin/matrix_rotate
# Вывод: ... with debug_info, not stripped
```

#### 3. Оптимизация компиляции

```bash
# Без оптимизации
make

# С оптимизацией -O2
make COMPILE_FLAGS="-O2"

# С агрессивной оптимизацией
make COMPILE_FLAGS="-O3 -funroll-loops"

# Комбинация флагов
make SYNTAX=att DEBUG=yes COMPILE_FLAGS="-O2 -pipe"
```

#### 4. Методы ввода данных (для будущей реализации)

```bash
# Ввод из консоли (по умолчанию)
make INPUT_METHOD=console

# Чтение из файла
make INPUT_METHOD=file

# Случайная генерация
make INPUT_METHOD=random
```

## Демонстрация инкрементальной сборки

Makefile правильно отслеживает зависимости и пересобирает только изменённые файлы:

```bash
# Первая сборка (все файлы)
make clean
make

# Проверка времени модификации
stat -c "%y %n" bin/obj/*.o bin/matrix_rotate

# Изменение одного файла
sleep 1
touch src/main.c

# Пересборка (только main.o будет перекомпилирован!)
make

# Проверка времени модификации снова
stat -c "%y %n" bin/obj/*.o bin/matrix_rotate
# Результат: только main.o и matrix_rotate имеют новое время
```

### Пример вывода:

```
==> Compiling C: src/main.c
gcc -Wall -m32 -DINPUT_CONSOLE -MD -c src/main.c -o bin/obj/main.o
    Object: bin/obj/main.o
==> Linking: bin/matrix_rotate
gcc -Wall -m32 -DINPUT_CONSOLE bin/obj/main.o bin/obj/rotate.o -o bin/matrix_rotate
==> Build complete: bin/matrix_rotate
```

**Обратите внимание**: `rotate.o` не перекомпилируется, так как исходный файл не изменился!

## Файлы зависимостей

Makefile автоматически создаёт файлы зависимостей (`.d`) для каждого C файла:

```bash
# Просмотр зависимостей
cat bin/obj/main.d
```

Пример содержимого:
```
bin/obj/main.o: src/main.c /usr/include/stdio.h \
  /usr/include/stdlib.h /usr/include/stdint.h \
  /usr/include/time.h ...
```

Эти файлы автоматически включаются в Makefile директивой:
```makefile
-include $(wildcard $(OBJ_DIR)/*.d)
```

## Продвинутые возможности

### Переопределение переменных

```bash
# Изменение компилятора
make CC=clang

# Изменение имени программы
make PROGRAM_NAME=my_matrix

# Изменение директорий
make SRC_DIR=source BIN_DIR=build
```

### Комбинированные сборки

```bash
# Оптимизированная сборка с AT&T синтаксисом
make SYNTAX=att COMPILE_FLAGS="-O3 -march=native"

# Отладочная сборка с дополнительными предупреждениями
make DEBUG=yes COMPILE_FLAGS="-Wall -Wextra -pedantic"
```

## Соответствие требованиям задания

### ✅ Основное задание (пункт 3-5)

- [x] Создан make-файл для автоматизации сборки проекта
- [x] Программа успешно компилируется и выполняется
- [x] При изменении одного файла перекомпилируются только необходимые модули
- [x] Неизменённые файлы не перекомпилируются (проверено через `stat`)

### ✅ Дополнительные задания (пункт 6-7)

#### Пункт 6: Высокий уровень автоматизации

- [x] Имя программы задаётся переменной `PROGRAM_NAME`
- [x] Флаги компиляции задаются переменной `COMPILE_FLAGS`
- [x] Каталоги задаются переменными `SRC_DIR`, `BIN_DIR`, `OBJ_DIR`
- [x] Зависимости формируются динамически (флаг `-MD`, файлы `.d`)
- [x] Исходные файлы определяются автоматически (`wildcard`)
- [x] Есть цель `clean` для удаления временных файлов
- [x] Есть цель `distclean` для полной очистки
- [x] Структура: `src/` (исходники), `bin/` (бинарники), `Makefile`

#### Пункт 7: Динамическое изменение функциональности

- [x] **Управление методом компиляции**: выбор между Intel и AT&T синтаксисом (`SYNTAX`)
- [x] **Управление вспомогательным функционалом**: отладочные символы (`DEBUG`)
- [x] **Управление методом обработки**: подготовлено для разных методов ввода (`INPUT_METHOD`)
- [x] **Кроссплатформенность**: структура поддерживает разные ОС

## Примеры работы

### 1. Базовая сборка и запуск

```bash
$ make
==> Compiling C: src/main.c
==> Assembling (Intel): src/rotate.asm
==> Linking: bin/matrix_rotate
==> Build complete

$ make run
==> Running program...
=== Поворот матрицы 3x3 ===
Исходная матрица:
   2    7   10
   8    9    3
   6    2    3

Матрица после поворота:
   6    8    2
   2    9    7
   3    3   10
```

### 2. Сборка с AT&T синтаксисом

```bash
$ make clean && make SYNTAX=att
==> Cleaning object files...
==> Compiling C: src/main.c
==> Assembling (AT&T): src/rotate_att.s
==> Linking: bin/matrix_rotate
==> Build complete
    Syntax: att
```

### 3. Отладочная сборка

```bash
$ make DEBUG=yes
==> Compiling C: src/main.c
gcc -Wall -m32 -g -DDEBUG -DINPUT_CONSOLE -MD -c src/main.c -o bin/obj/main.o
==> Assembling (Intel): src/rotate.asm
nasm -f elf32 -g -F dwarf src/rotate.asm -o bin/obj/rotate.o
==> Linking: bin/matrix_rotate
==> Build complete
    Debug: yes
```

## Технические детали

### Используемые функции make

- `wildcard` - поиск файлов по шаблону
- `patsubst` - замена паттерна в списке
- `basename` - извлечение имени без расширения
- `addprefix` - добавление префикса
- `addsuffix` - добавление суффикса
- `notdir` - извлечение имени файла без пути

### Условная компиляция

```makefile
ifeq ($(SYNTAX),att)
    ASM_SRC := rotate_att.s
    ASM_COMPILER := $(AS)
else
    ASM_SRC := rotate.asm
    ASM_COMPILER := $(ASM)
endif
```

### Порядок правил (order-only prerequisites)

```makefile
$(OBJ_DIR)/%.o: %.c | $(OBJ_DIR)
    # | $(OBJ_DIR) означает, что директория должна существовать,
    # но её время модификации не влияет на пересборку
```

## Заключение

Этот Makefile демонстрирует все основные концепции и возможности GNU Make:

1. ✅ Автоматическое определение зависимостей
2. ✅ Инкрементальная сборка
3. ✅ Шаблонные правила
4. ✅ Переменные и их переопределение
5. ✅ Условная компиляция
6. ✅ Структурирование проекта
7. ✅ Динамическое изменение параметров сборки
8. ✅ Фиктивные цели
9. ✅ Автоматические переменные
10. ✅ Функции обработки строк

Все требования лабораторной работы выполнены в полном объёме.

## Таблица результатов тестирования

| Команда | Синтаксис ASM | Отладка | Размер | Время сборки |
|---------|---------------|---------|--------|--------------|
| `make` | Intel | Нет | 16K | ~0.5s |
| `make SYNTAX=att` | AT&T | Нет | 16K | ~0.5s |
| `make DEBUG=yes` | Intel | Да | 19K | ~0.6s |
| `make SYNTAX=att DEBUG=yes` | AT&T | Да | 19K | ~0.6s |

## Сравнение размеров объектных файлов

```bash
# Обычная сборка
$ make clean && make
$ ls -lh bin/obj/
-rw-rw-r-- 1 user user 3.4K main.o
-rw-rw-r-- 1 user user  672 rotate.o

# С отладкой
$ make clean && make DEBUG=yes
$ ls -lh bin/obj/
-rw-rw-r-- 1 user user 4.2K main.o     (+800 байт)
-rw-rw-r-- 1 user user 1.3K rotate.o   (+600 байт)
```

Отладочные символы увеличивают размер на ~20-30%.
