/*
 * Задание 1 (Часть 2): Поворот матрицы по часовой стрелке
 * 
 * Программа создаёт квадратную матрицу, заполняет её случайными числами
 * и выполняет поворот: инвертированный i-й столбец становится i-й строкой.
 * 
 * Компиляция: см. инструкцию ниже
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>

// Объявление внешней функции на ассемблере
// Принимает: указатель на матрицу, указатель на временный буфер, размер
extern void rotate_matrix(int32_t* matrix, int32_t* temp, int32_t size);

// ========================================
// Функция вывода матрицы в консоль
// ========================================
void print_matrix(int32_t* matrix, int32_t size) {
    for (int32_t i = 0; i < size; i++) {
        for (int32_t j = 0; j < size; j++) {
            // Индекс в одномерном массиве: i * size + j
            printf("%8d ", matrix[i * size + j]);
        }
        printf("\n");
    }
    printf("\n");
}

// ========================================
// Главная функция
// ========================================
int main(int argc, char* argv[]) {
    // --- Проверка аргументов командной строки ---
    if (argc < 2) {
        fprintf(stderr, "Использование: %s <размер_матрицы> [мин_значение] [макс_значение]\n", argv[0]);
        fprintf(stderr, "Пример: %s 5 -100 100\n", argv[0]);
        return 1;
    }

    // --- Парсинг аргументов ---
    int32_t size = atoi(argv[1]);  // Размер матрицы (обязательный)
    
    if (size <= 0) {
        fprintf(stderr, "Ошибка: размер матрицы должен быть положительным числом\n");
        return 1;
    }

    // Диапазон случайных чисел (опциональные параметры)
    int32_t min_val = -1000;        // По умолчанию
    int32_t max_val = 1000;
    
    if (argc >= 3) {
        min_val = atoi(argv[2]);    // Минимальное значение
    }
    if (argc >= 4) {
        max_val = atoi(argv[3]);    // Максимальное значение
    }

    if (min_val >= max_val) {
        fprintf(stderr, "Ошибка: минимум должен быть меньше максимума\n");
        return 1;
    }

    printf("=== Поворот матрицы %dx%d ===\n", size, size);
    printf("Диапазон значений: [%d, %d]\n\n", min_val, max_val);

    // --- Выделение памяти для матрицы ---
    // Матрица size×size хранится как одномерный массив size*size элементов
    int32_t* matrix = (int32_t*)malloc(size * size * sizeof(int32_t));
    if (matrix == NULL) {
        fprintf(stderr, "Ошибка: не удалось выделить память для матрицы\n");
        return 1;
    }

    // --- Выделение памяти для временного буфера ---
    // Нужен для алгоритма поворота
    int32_t* temp = (int32_t*)malloc(size * size * sizeof(int32_t));
    if (temp == NULL) {
        fprintf(stderr, "Ошибка: не удалось выделить память для временного буфера\n");
        free(matrix);
        return 1;
    }

    // --- Инициализация генератора случайных чисел ---
    srand(time(NULL));

    // --- Заполнение матрицы случайными числами ---
    int32_t range = max_val - min_val + 1;  // Размер диапазона
    for (int32_t i = 0; i < size * size; i++) {
        // Генерируем число в диапазоне [min_val, max_val]
        matrix[i] = min_val + (rand() % range);
    }

    // --- Вывод исходной матрицы ---
    printf("Исходная матрица:\n");
    print_matrix(matrix, size);

    // --- ВЫЗОВ АССЕМБЛЕРНОЙ ФУНКЦИИ ---
    // Передаём: указатель на матрицу, временный буфер, размер
    rotate_matrix(matrix, temp, size);

    // --- Вывод результата ---
    printf("Матрица после поворота:\n");
    print_matrix(matrix, size);

    // --- Освобождение памяти ---
    free(temp);
    free(matrix);

    return 0;
}
